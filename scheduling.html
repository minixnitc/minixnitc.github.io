<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Process Scheduling</title>
 
    <!-- Bootstrap -->
    <link href="bootstrap-3.3.2-dist/css/bootstrap.min.css" rel="stylesheet">
 	<link rel="stylesheet" type="text/css" href="style.css">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
  	<div class="container my-custom-container">
  		<h1>Process Scheduling</h1>
  			<p>
  				Process blocks when it make request for input, and allow other process to run.
  			</p>
  			<p>
  				When input becomes available, current running process is interrupted by the disk, keyboard and other hardware.
  			</p>
  			<p>
  				Clock also generates interrupts. 
  			</p>
  			<p>
  				Lower layer of minix3 hides these interrupts by turning them into messages. When Input/Oputput device completes an operation , it sends a message to some process, waking it up and making it eligible to run. 	Interrupts generated by softwares are called <span class="make-bold">traps</span>. The <span class="make-bold">send</span> and <span class="make-bold">receive</span> operation are translated by system library into software interrupts instructions which has exactly same effect as hardware generated interrupts. The process that executes software interrupts is immediately blocked and the kernel is activated to process the interrupt
  			</p>
  			<p>
  				Minix3 uses <span class="make-bold">multilevel queuing system</span> for scheduling. Sixteen queues are defined, the lowest priority queue is used only by the <span class="make-bold">idle process</span>. User process start by default in a queue several levels higher than the  lowest one. 
  				Server processes have higher priorities than user processes and drivers have higher priorities than servers and clock and system task have highest priority. 
  			</p>
  			<p>
  				User process has relatively low <a href="ref.html#quantum">quantum</a>, and drivers and servers should run until they block but they are given higher <a href="ref.html#quantum">quantum</a> inorder to prevent malfunctioning. If the process use entire quantum, the process whether user, driver or server they are <a href="ref.html#preemption"> preempted </a> inorder to not to hang the system. 
  			</p>
  			<p>
  				If a process has used consecutive quantums and still did not exit then, this is taken as a sign that the process is stuck in an infinite loop and its priority is lowered and gets a chance to run. 
  				A process can be promoted to higher priority queue if a process uses all its quantum but not preventing other processes from running (upto maximum priority permitted for it).  
  			</p>
  			<p>
  				If a process has not used its entire quantum and blocked, then it means it got blocked waiting for i/o. After i/o is complete the process is put at the head of the queue with remaining time quantum. The process that has used the entire time quantum is placed at the end of the queue. 
  			</p>
  			<p>
  				User processes will not run until all the system processes has nothing to do (user process can not prevent running of system process)
  			</p>
  			<p>
  				When picking a process to run, scheduler checks the highest priority queue. If one or more processes are ready, then the process at the head is executed. If no process than the next lower level priority queue is similarly tested. If no process is ready  
  			</p>
  			<p>
  				At each clock tick, check is made to see if the current process is has run for more than the alloted quantum. If yes, then scheduler moves the process to the end of the queue. Drivers and servers are given time quantum large enough that they are never preempted by the clock. 
  			</p>
        <br>
        <br>
        <h4>Reference:</h4>
        <ul>
          <li>
            <a href="http://www.minix3.org/docs/scheduling/report.pdf">User mode scheduling in minix3 </a>
          </li>
          <li>
            Operating System Design and Implementation, Third Edition By Andrew S. Tanenbaum and Albert S. Woodhull
          </li>
        </ul>
	   
 	</div>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap-3.3.2-dist/js/bootstrap.min.js"></script>
  </body>
</html>